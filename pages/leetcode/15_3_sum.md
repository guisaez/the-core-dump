### 15. 3Sum

[View Problem in Leetcode](https://leetcode.com/problems/3sum/description/)

My analysis:

1. A brute force approach would be to generate all possible triplets from the array and for each of them ensure their values have not been used yet, that is (they are not duplicate, [i,j,k], [j,k,i]) and check if `nums[i] + nums[j] + nums[k] = 0`. It will take O(N^3) to generate all possible triplets in this case. Terrible performance!

2. What if we sort the array? Do we get any advantage? If I were to do this manually I would probably have the array sorted. I can fix i and then look for j and k that will satisfy the other conditions.
In this case I could even say that:

`-nums[i] = nums[j] + nums[k]`

This has become a [2Sum](./1_two_sum.md) Problem for each `i` that is fixed.

##### Code:
```go
func threeSum(nums []int) [][]int {
    sort.Ints(nums)

    triplets := [][]int{}

    for i := 0; i < len(nums) - 2; i++ {
        // Skip duplicate values
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        left, right := i + 1, len(nums) - 1

        for left < right {
            target := nums[left] + nums[right]
            if target == -nums[i] {
                triplets = append(triplets, []int{nums[i], nums[left], nums[right]})

                // Skip duplicate values for the left pointer
                for left < right && nums[left] == nums[left+1] {
                    left++
                }
                // Skip duplicate values for the right pointer
                for left < right && nums[right] == nums[right-1] {
                    right--
                }

                left++
                right--
            }
            if target > -nums[i] {
                right--
            }
            if target < -nums[i] {
                left++
            }
        }
    }

    return triplets
}
```



